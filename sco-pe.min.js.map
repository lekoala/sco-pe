{
  "version": 3,
  "sources": ["src/Scope.js", "sco-pe.js"],
  "sourcesContent": ["/**\n * @typedef {Function} PromiseHandler\n * @returns {Promise}\n */\n\n/**\n * @typedef ScopeConfig\n * @property {Boolean} debug\n * @property {Number} debounceTime\n * @property {String} activeClass\n * @property {String} reloadHeader\n * @property {String} titleHeader\n * @property {String} styleHeader\n * @property {String} scriptHeader\n * @property {PromiseHandler} confirmHandler\n * @property {String} statusHeader\n * @property {Function} statusHandler\n * @property {Function} onLoad\n */\nlet config = {\n  debug: false,\n  debounceTime: 300,\n  activeClass: \"active\",\n  reloadHeader: \"X-Reload\",\n  titleHeader: \"X-Title\",\n  cssHeader: \"x-include-css\",\n  jsHeader: \"x-include-js\",\n  confirmHandler: (message) => {\n    return new Promise((resolve, reject) => {\n      if (confirm(message)) {\n        resolve();\n      } else {\n        reject();\n      }\n    });\n  },\n  statusHeader: \"X-Status\",\n  statusHandler: (message, statusCode) => {\n    alert(message);\n  },\n  onLoad: () => {},\n};\n\n/**\n * @type {AbortController}\n */\nlet globalAbortController = null;\n\n/**\n * @type {Number}\n */\nlet scriptsLoading = 0;\n/**\n * @type {Array}\n */\nlet pendingInlineScripts = [];\n/**\n * @type {Array}\n */\nlet pendingExternalScripts = [];\n\n/**\n * @type {Number}\n */\nlet scopesLoading = 0;\n\nlet scopesLoadingTimeout;\n\nlet pageLoaded = false;\n\n/**\n * @param {HTMLElement} el\n * @returns {Array}\n */\nfunction getEvents(el) {\n  if (el instanceof HTMLFormElement) {\n    return [\"submit\"];\n  }\n  const ev = el.dataset.scopeOn || \"click\";\n  return ev.split(\",\");\n}\n\n/**\n * @param {HTMLElement} el\n * @returns {String}\n */\nfunction getAction(el) {\n  return (\n    el.getAttribute(\"action\") ||\n    el.dataset.scopeAction ||\n    el.getAttribute(\"href\")\n  );\n}\n\n/**\n * @param {Function} func\n * @param {number} timeout\n * @returns {Function}\n */\nfunction debounce(func, timeout = 300) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      //@ts-ignore\n      func.apply(this, args);\n    }, timeout);\n  };\n}\n\n/**\n * @param {*} v\n * @returns {Boolean}\n */\nfunction parseBool(v) {\n  return [\"1\", \"true\", true, 1].includes(v);\n}\n\n/**\n * @param {HTMLElement} el\n * @param {HTMLElement} parentScope\n * @returns {Boolean}\n */\nfunction getHistory(el, parentScope = null) {\n  let history = \"true\";\n  if (el.dataset.scopeHistory) {\n    history = el.dataset.scopeHistory;\n  } else if (parentScope && parentScope.dataset.scopeHistory) {\n    history = parentScope.dataset.scopeHistory;\n  }\n  return parseBool(history);\n}\n\n/**\n * @param {String} html\n * @return {Document}\n */\nfunction htmlToDocument(html) {\n  const parser = new DOMParser();\n  return parser.parseFromString(html, \"text/html\");\n}\n\n/**\n * @param {Element} node\n * @returns {Boolean}\n */\nfunction isNodeEmpty(node) {\n  return node.textContent.trim() === \"\" && !node.firstElementChild;\n}\n\n/**\n * @param {String|URL} url\n * @returns {URL}\n */\nfunction expandURL(url) {\n  const str = url ? url.toString() : \"#\";\n  return new URL(str, document.baseURI);\n}\n\n/**\n * @param {String|URL} url\n * @returns {Boolean}\n */\nfunction isExternalURL(url) {\n  if (!url) {\n    return;\n  }\n  return expandURL(url).origin !== location.origin;\n}\n\n/**\n * @param {URL} url\n * @returns {String}\n */\nfunction getAnchor(url) {\n  if (!url) {\n    return;\n  }\n  let anchorMatch;\n  if (url.hash) {\n    return url.hash.slice(1);\n  } else if ((anchorMatch = url.href.match(/#(.*)$/))) {\n    return anchorMatch[1];\n  }\n  return null;\n}\n\n/**\n * @param {String|URL} url\n * @returns {Boolean}\n */\nfunction isAnchorURL(url) {\n  return getAnchor(expandURL(url)) !== null;\n}\n\n/**\n * @param {String} str\n * @returns {String}\n */\nfunction simpleHash(str) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash &= hash; // Convert to 32bit integer\n  }\n  return new Uint32Array([hash])[0].toString(36);\n}\n\n/**\n * @param {String} message\n */\nfunction log(message) {\n  if (config.debug) {\n    console.log(`[sco-pe] ${message}`);\n  }\n}\n\n// Make a full page load on back\nwindow.addEventListener(\"popstate\", (event) => {\n  if (!event.state) {\n    return;\n  }\n  const id = event.state.id || null;\n  if (!id) {\n    return;\n  }\n  /**\n   * @type {Scope}\n   */\n  const scope = document.querySelector(`sco-pe[id=\"${id}\"]`);\n  if (!scope) {\n    // Do a full page load\n    window.location.replace(document.location.toString());\n    return;\n  }\n  log(`Restore location from history`);\n  scope.loadURL(document.location.toString());\n});\n\nclass Scope extends HTMLElement {\n  constructor() {\n    super();\n\n    /**\n     * @type {AbortController}\n     */\n    this.abortController = null;\n    /**\n     * @type {Boolean}\n     */\n    this.init = false;\n    /**\n     * @type {Array}\n     */\n    this.events = [\"click\", \"submit\"];\n    /**\n     * @type {Function}\n     */\n    this.loadFunc = debounce((trigger) => {\n      this.load(trigger);\n    }, config.debounceTime);\n  }\n\n  /**\n   * @param {ScopeConfig|Object} data\n   */\n  static configure(data) {\n    config = Object.assign(config, data);\n  }\n\n  handleEvent(ev) {\n    // Check for nested scope\n    if (ev.target.closest(\"sco-pe\") !== this) {\n      return;\n    }\n\n    // Don't handle events if disabled\n    if (parseBool(this.dataset.scopeDisabled)) {\n      return;\n    }\n\n    /**\n     * @type {HTMLElement}\n     */\n    let trigger = ev.target.closest(\"a,button,[data-scope-action]\");\n\n    if (ev.type === \"submit\") {\n      trigger = ev.target;\n    }\n\n    if (trigger) {\n      const events = getEvents(trigger);\n      // Ignore events that we don't watch\n      if (!events.includes(ev.type)) {\n        return;\n      }\n      const action = getAction(trigger);\n      // Ignore empty, external and anchors links\n      if (!action || isExternalURL(action) || isAnchorURL(action)) {\n        return;\n      }\n      log(`Handling ${ev.type} on ${trigger.nodeName}`);\n      ev.preventDefault();\n\n      const load = () => {\n        // For click, no debounce\n        if (ev.type === \"click\") {\n          this.load(trigger);\n        } else {\n          this.loadFunc(trigger);\n        }\n      };\n      // Check confirm ?\n      if (trigger.dataset.scopeConfirm) {\n        config\n          .confirmHandler(trigger.dataset.scopeConfirm)\n          .then(load)\n          .catch((err) => null);\n      } else {\n        load();\n      }\n    }\n  }\n\n  abortLoading() {\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n  }\n\n  /**\n   * @param {HTMLElement} el\n   */\n  async load(el) {\n    // Build url\n    let action = getAction(el);\n    let url = new URL(action, window.location.href).href; // make absolute\n    let urlWithParams = url;\n    const isLink = el.nodeName === \"A\";\n    const method = (\n      el.getAttribute(\"method\") ||\n      el.dataset.scopeMethod ||\n      \"GET\"\n    ).toUpperCase();\n    // Update history for links for named scopes\n    let pushToHistory =\n      isLink && getHistory(el, this) && this.hasAttribute(\"id\");\n    let postBody;\n\n    // Pass along current query string and params for elements with value\n    const searchParams = new URLSearchParams(window.location.search);\n    //@ts-ignore\n    const elValue = el.value !== \"undefined\" ? el.value : el.dataset.scopeValue;\n    if (typeof elValue !== \"undefined\") {\n      searchParams.set(\"value\", elValue);\n      urlWithParams = `${url}?${searchParams.toString()}`;\n      postBody = searchParams;\n    }\n\n    // Pass form data\n    if (el instanceof HTMLFormElement) {\n      const formData = new FormData(el);\n      postBody = formData;\n    }\n\n    // Do we target a specific scope ?\n    // Always use GET request for sco-pe requests and delegate loading to instance\n    const target = el.dataset.scopeTarget || this.dataset.scopeTarget;\n    if (target && target !== \"_self\") {\n      log(`Loading partial document into scope ${target}`);\n      document.getElementById(target).setAttribute(\"src\", urlWithParams);\n      return;\n    }\n\n    if (pushToHistory) {\n      const id = this.getAttribute(\"id\");\n      const state = {\n        id,\n        url,\n      };\n      history.pushState(state, null, url);\n    }\n    if (isLink) {\n      this.setActive(el);\n    }\n\n    if (method === \"GET\") {\n      url = urlWithParams;\n    }\n    const body = method === \"POST\" ? postBody : null;\n    await this.loadURL(url, {\n      method,\n      body,\n    });\n  }\n\n  /**\n   * @param {HTMLElement} el\n   */\n  setActive(el) {\n    this.querySelectorAll(`.${config.activeClass}`).forEach((el) => {\n      el.classList.remove(config.activeClass);\n    });\n    el.classList.add(config.activeClass);\n  }\n\n  /**\n   * @param {String} url\n   * @param {Object} fetchOptions\n   */\n  async loadURL(url, fetchOptions = {}) {\n    if (!fetchOptions.signal) {\n      log(`GET ${url}`);\n      pageLoaded = false;\n      // If not targeting a specific scope, we use a global context\n      if (globalAbortController) {\n        globalAbortController.abort();\n      }\n      globalAbortController = new AbortController();\n      fetchOptions.signal = globalAbortController.signal;\n    }\n    const options = Object.assign(\n      {\n        method: \"GET\",\n      },\n      fetchOptions\n    );\n    const response = await fetch(url, options);\n    if (!response.ok) {\n      const message =\n        response.headers.get(config.statusHeader) || response.statusText;\n      config.statusHandler(message, response.status);\n      return;\n    }\n    this.processHeaders(response);\n    const data = await response.text();\n    this.processResponse(data);\n  }\n\n  /**\n   * @param {Response} response\n   */\n  processHeaders(response) {\n    if (config.statusHeader) {\n      const status = response.headers.get(config.statusHeader);\n      if (status) {\n        config.statusHandler(status, response.status);\n      }\n    }\n    if (config.titleHeader) {\n      const title = response.headers.get(config.titleHeader);\n      if (title) {\n        document.title = title;\n      }\n    }\n    if (config.reloadHeader) {\n      const reload = response.headers.get(config.reloadHeader);\n      if (reload) {\n        window.location.reload();\n      }\n    }\n    if (config.jsHeader) {\n      const js = response.headers.get(config.jsHeader);\n      if (js) {\n        js.split(\",\").forEach((src) => {\n          this._loadScript(src);\n        });\n      }\n    }\n    if (config.cssHeader) {\n      const css = response.headers.get(config.cssHeader);\n      if (css) {\n        css.split(\",\").forEach((src) => {\n          this._loadStyle(src);\n        });\n      }\n    }\n  }\n\n  /**\n   * @param {HTMLHeadElement} head\n   */\n  processHead(head) {\n    log(`Process head`);\n\n    // Update title\n    const title = head.querySelector(\"title\");\n    if (title) {\n      document.title = title.textContent;\n    }\n  }\n\n  /**\n   * @param {HTMLBodyElement} body\n   */\n  processBody(body) {\n    document.body.style.cssText = body.style.cssText;\n    const attrs = [\"class\"];\n    attrs.forEach((attr) => {\n      document.body.setAttribute(attr, body.getAttribute(\"class\"));\n    });\n  }\n\n  /**\n   * @param {String} src\n   * @param {String} type\n   * @returns {Boolean} Is a new script created?\n   */\n  _loadScript(src, type = null) {\n    if (!type) {\n      type = \"text/javascript\";\n    }\n    const existingScript = document.querySelector(`script[src=\"${src}\"]`);\n    if (existingScript) {\n      return false;\n    }\n    scriptsLoading++;\n    log(`Loading script ${src}`);\n    pendingExternalScripts.push({\n      type,\n      src,\n    });\n    return true;\n  }\n\n  /**\n   * Scripts needs to load sequentially to respect dependencies\n   */\n  _processScriptsQueue() {\n    const allLoaded = pendingExternalScripts.length === 0;\n    const script = pendingExternalScripts.shift();\n    if (allLoaded) {\n      this._processInlineQueue();\n      log(`All scripts loaded`);\n      return;\n    }\n    const newScript = document.createElement(\"script\");\n    newScript.setAttribute(\"type\", script.type);\n    newScript.setAttribute(\"src\", script.src);\n    newScript.onload = newScript.onerror = (ev) => {\n      log(`Loaded script ${script.src}`);\n      this._processScriptsQueue();\n    };\n    document.head.appendChild(newScript);\n  }\n\n  _loadInlineScript(content, type = \"application/javascript\", id = null) {\n    log(`Loading inline script`);\n    const inlineScript = document.createElement(\"script\");\n    inlineScript.setAttribute(\"type\", type);\n    inlineScript.setAttribute(\"id\", id);\n    inlineScript.innerHTML = content;\n\n    const existingInlineScript = document.querySelector(`script[id=\"${id}\"]`);\n    // Scripts get executed each time on load\n    if (existingInlineScript) {\n      existingInlineScript.replaceWith(inlineScript);\n    } else {\n      document.head.appendChild(inlineScript);\n    }\n  }\n\n  _processInlineQueue() {\n    log(`Executing ${pendingInlineScripts.length} inline scripts`);\n    pendingInlineScripts.forEach((script) => {\n      this._loadInlineScript(script.content, script.type, script.id);\n    });\n    pendingInlineScripts = [];\n\n    // Execute global onLoad. It must happen only once per \"load\" event,\n    // which can be multiple scopes or only a partial scope\n    log(`Calling global onload`);\n    config.onLoad();\n  }\n\n  _loadStyle(href) {\n    const existingStyle = document.querySelector(`link[href=\"${href}\"]`);\n    if (existingStyle) {\n      return;\n    }\n    log(`Loading style ${href}`);\n    const newStyle = document.createElement(\"link\");\n    newStyle.setAttribute(\"rel\", \"stylesheet\");\n    newStyle.setAttribute(\"href\", href);\n    document.head.appendChild(newStyle);\n  }\n\n  /**\n   * @param {DocumentFragment} doc\n   * @returns {Boolean}\n   */\n  processScriptsAndStyles(doc) {\n    // Make sure our existing inline scripts & styles have a custom id\n    document\n      .querySelectorAll(\"script:not([src]):not([id]),style:not([id])\")\n      .forEach((el) => {\n        const hash = simpleHash(el.innerHTML);\n        const id = `${el.nodeName.toLowerCase()}-${hash}`;\n        el.setAttribute(\"id\", id);\n      });\n\n    // Append new styles and scripts\n    let canTriggerImmediately = true;\n    doc.querySelectorAll(\"script\").forEach((script) => {\n      const src = script.getAttribute(\"src\");\n      const type = script.type || \"text/javascript\";\n      if (!src) {\n        // Inline scripts are always executed except unless they have an id\n        const hash = simpleHash(script.innerHTML);\n        const id = script.getAttribute(\"id\") || `script-${hash}`;\n        const existingInlineScript = document.querySelector(\n          `script[id=\"${id}\"]`\n        );\n        if (existingInlineScript && script.getAttribute(\"id\")) {\n          return;\n        }\n        const content = script.innerHTML;\n        // Inline module script are executed immediately and don't respect order, so we need to execute them later\n        pendingInlineScripts.push({\n          content,\n          type,\n          id,\n        });\n      } else {\n        const isNew = this._loadScript(src, type);\n        if (isNew) {\n          canTriggerImmediately = false;\n        }\n      }\n    });\n    this._processScriptsQueue();\n    log(\n      `There are ${pendingInlineScripts.length} pending inline scripts (${canTriggerImmediately})`\n    );\n\n    // Obviously order can get tricky here, namespace as needed to avoid collisions\n    // or avoid scope pollution\n    doc.querySelectorAll('style,link[rel=\"stylesheet\"]').forEach((style) => {\n      const href = style.getAttribute(\"href\");\n      if (!href) {\n        // Inline styles get a unique hash based on their content to avoid loading them multiple times\n        const hash = simpleHash(style.innerHTML);\n        const id = style.getAttribute(\"id\") || `style-${hash}`;\n        const existingInlineStyle = document.querySelector(`style[id=\"${id}\"]`);\n        if (existingInlineStyle) {\n          return;\n        }\n        log(`Loading inline style`);\n        const inlineStyle = document.createElement(\"style\");\n        inlineStyle.innerHTML = style.innerHTML;\n        inlineStyle.setAttribute(\"id\", id);\n        document.head.appendChild(inlineStyle);\n      } else {\n        this._loadStyle(href);\n      }\n    });\n\n    return canTriggerImmediately;\n  }\n\n  /**\n   * @param {String} data\n   */\n  processResponse(data) {\n    // The response can be a full html document or a partial document\n    const isFull = data.match(/<!doctype\\s+html[\\s>]/i);\n\n    // It may contain one or more sco-pe to replace\n    const containsScope = data.indexOf(\"<sco-pe\") !== -1;\n\n    const tmp = htmlToDocument(data);\n    const canTriggerImmediately = this.processScriptsAndStyles(tmp);\n\n    if (isFull || containsScope) {\n      log(`Loading scopes ${isFull ? \"(full)\" : \"(partial)\"}`);\n\n      const head = tmp.querySelector(\"head\");\n      if (head) {\n        this.processHead(head);\n      }\n      const body = tmp.querySelector(\"body\");\n      if (body) {\n        this.processBody(body);\n      }\n\n      const scopes = tmp.querySelectorAll(\"sco-pe\");\n\n      // No scopes ? replace body\n      if (!scopes.length) {\n        document.body.innerHTML = data;\n        this.checkScopesAreLoaded(canTriggerImmediately);\n      }\n\n      // Scopes are never replaced because maybe we have configured listeners on them\n      // We expect that they get the same attributes except src that can change\n      scopes.forEach(\n        /**\n         * @param {Scope} newScope\n         */\n        (newScope) => {\n          const id = newScope.getAttribute(\"id\");\n          if (!id) {\n            log(`Scope without id`);\n            return;\n          }\n          const src = newScope.getAttribute(\"src\");\n          if (isNodeEmpty(newScope) && !src) {\n            log(`Empty scope for ${id}`);\n            return;\n          }\n          /**\n           * @type {Scope}\n           */\n          //@ts-ignore\n          const oldScope = document.getElementById(id);\n          if (!oldScope) {\n            log(`No matching scope for ${id}`);\n            return;\n          }\n          if (\n            src &&\n            expandURL(src).toString() === expandURL(oldScope.src).toString()\n          ) {\n            log(`Url has not changed for ${id}`);\n            return;\n          }\n          log(`Replacing ${id} content`);\n          if (src) {\n            oldScope.src = src;\n            // afterLoad will happen automatically through connectedCallback\n          } else {\n            oldScope.innerHTML = newScope.innerHTML;\n            this.afterLoad(canTriggerImmediately);\n          }\n        }\n      );\n    } else {\n      log(`Loading partial document into self ${this.id}`);\n      this.innerHTML = data;\n      this.afterLoad(canTriggerImmediately);\n    }\n  }\n\n  /**\n   * Load src. You can check if there is server provided content\n   * to avoid a fetch request (only used in connectedCallback)\n   *\n   * @param {Boolean} check Check if there is existing content\n   */\n  async loadContent(check = false) {\n    const src = this.src;\n    const preventLoading = check && !isNodeEmpty(this);\n    if (src && !preventLoading) {\n      this.classList.add(\"scope-loading\");\n      this.classList.remove(\"scope-loaded\");\n\n      this.abortLoading();\n      this.abortController = new AbortController();\n      await this.loadURL(src, {\n        signal: this.abortController.signal,\n      });\n    } else {\n      this.afterLoad(true);\n    }\n  }\n\n  afterLoad(canTriggerImmediately = false) {\n    this.listenToEvents();\n\n    // Mark active class in any link matching href\n    this.querySelectorAll(`a`).forEach((el) => {\n      const url = expandURL(el.getAttribute(\"href\"));\n      if (url.toString() == document.location.href) {\n        this.setActive(el);\n      }\n    });\n\n    this.classList.remove(\"scope-loading\");\n    this.classList.add(\"scope-loaded\");\n    this.dispatchEvent(new CustomEvent(\"scope-loaded\"));\n\n    // We have only one callback to avoid calling this multiple times\n    this.checkScopesAreLoaded(canTriggerImmediately);\n  }\n\n  checkScopesAreLoaded(canTriggerImmediately) {\n    if (scopesLoadingTimeout) {\n      clearTimeout(scopesLoadingTimeout);\n    }\n    scopesLoadingTimeout = setTimeout(() => {\n      scopesLoading = document.querySelectorAll(\n        \"sco-pe:not(.scope-loaded)\"\n      ).length;\n      if (!scopesLoading && canTriggerImmediately) {\n        this._processInlineQueue();\n        log(`All scripts loaded (no scripts to load)`);\n      }\n    });\n  }\n\n  listenToEvents() {\n    // Intercept all relevant events\n    this.querySelectorAll(\"[data-scope-on]\").forEach(\n      /**\n       * @param {HTMLElement} el\n       */\n      (el) => {\n        this.events = this.events.concat(getEvents(el));\n      }\n    );\n\n    this.events.forEach((event) => {\n      this.addEventListener(event, this);\n    });\n  }\n\n  /**\n   * @param {String} url\n   * @param {Object} fetchOptions\n   * @returns {Promise<String>}\n   */\n  async fetchSelf(url, fetchOptions = {}) {\n    this.abortLoading();\n    this.abortController = new AbortController();\n    const options = Object.assign(\n      {\n        signal: this.abortController.signal,\n      },\n      fetchOptions\n    );\n    const response = await fetch(url, options);\n    return await response.text();\n  }\n\n  static get observedAttributes() {\n    return [\"src\"];\n  }\n\n  set src(v) {\n    this.setAttribute(\"src\", v);\n  }\n\n  get src() {\n    return this.getAttribute(\"src\");\n  }\n\n  attributeChangedCallback(attr, oldVal, newVal) {\n    if (!this.init) {\n      return;\n    }\n    switch (attr) {\n      case \"src\":\n        this.loadContent();\n        break;\n    }\n  }\n\n  connectedCallback() {\n    // delay execution until the Event Loop is done and all DOM is parsed\n    // @link https://stackoverflow.com/questions/70949141/web-components-accessing-innerhtml-in-connectedcallback/75402874\n    setTimeout(() => {\n      scopesLoading = document.querySelectorAll(\n        \"sco-pe:not(.scope-loaded)\"\n      ).length;\n      // content can be provided by server rendering, in this case, don't load\n      this.loadContent(true);\n      this.init = true;\n      log(`Scope created ${this.id}`);\n    });\n  }\n\n  disconnectedCallback() {\n    this.events.forEach((event) => {\n      this.removeEventListener(event, this);\n    });\n  }\n}\n\nexport default Scope;\n", "import Scope from \"./src/Scope.js\";\n\ncustomElements.define(\"sco-pe\", Scope);\n"],
  "mappings": "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",
  "names": []
}
